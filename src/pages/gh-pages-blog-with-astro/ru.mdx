---
layout: "../../layouts/ArticleLayout.astro"

title: "Создание и деплой блога на GitHub Pages с Astro"
caption: "Делаю шустрый блог без бэкэнда, сервера и всяческих затрат, но при помощи Astro и GitHub Pages"
date: "25.11.2022"
duration: "15"
tags: ["Frontend", "Astro", "Гайд"]
---

## Введение

Итак, я решил сделать личный микро-блог и заодно попробовать [Astro.js](https://astro.build).

**_Поскольку я жадина_** и не хочу тратить ни копейки на всякие домены, хостинги и так далее, для деплоя был выбран мною любимый сервис GitHub Pages, который позволяет хостить там сайты на классическом стэке HTML-CSS-JS, поэтому Next.js сразу же для таких условий не подходит, так как это full-stack решение и требует полноценный серверсайд для работы.

В статье я буду опускать много моментов, чтобы это не превратилось в дипломную работу, вся необходимая информация есть в отличной [официальной документации Astro](https://docs.astro.build/en/getting-started/).

## Почему Astro?

В последнее время, веб-фреймворк Astro начал регулярно появляться в моём инфополе и исключительно в положительном ключе, поэтому решил пощупать, что же это такое.

![Astro homepage](/blog//assets/gh-pages-blog-with-astro/astro-home.png)

Обращаясь к документации Astro:

> Astro is an all-in-one web framework for building fast, content-focused websites.

Просто говоря - многостраничность, много контента, надо быстро - Астро. По сравнению с Next.js это намного более компактное и намного более шустрое решение, поддерживающее как SSG (Static Site Generation), так и SSR (Server Side Rendering). Крупным плюсом является интеграция буквально со всеми фронтэнд JavaScript фреймворками, и более того, весь процесс понятно и подробно описан в документации, вторым огромным плюсом является Vite под капотом, я ненавижу Webpack, я не знаю людей, которым он искренне нравится, поэтому наличию Vite несомненно рад.

Быстро прошёлся по документации и понял, что это идеальное решение для server-less, backend-less блога, как из-за статической генерации (потому что другая на GitHub Pages и не доступна), так и из-за удобных утилит, позволяющих превращать Markdown разметку в вёрстку и полноценные маршруты.

> _А ещё практически из коробки идёт поддержка MDX, что позволяет писать компоненты при помощи языка Markdown. Это, наверное, один из главных поводов использовать этот фреймворк._

## Создание проекта

Я сразу решил создавать абсолютно пустой проект вопреки рекомендованному шаблону с "best practices", так как захотел всё узнать постепенно через весьма и весьма удобную документацию.

Началось всё с того, что я минуту смотрел на командную строку ожидая инициализации, чтобы в итоге осознать, что у них с CLI утилитой какой-то баг (либо это PowerShell), который при введении названия папки, в которой следует инициализировать проект, ничего не делал. Оказалось, что нужно ещё раз нажать Enter, но в поле ввода попадает только первый символ из введённого названия, в итоге вместо папки `blog` получил `b`, забавно.

Но исправляется это легко, простым указанием названия папки прямо в команде `npm create` (я использовл NPM, вы же можете YARN или PNPM по своему вкусу):

```bash
npm create astro@latest blog
```

Пошла красивая радужная инициализация и установка зависимостей. Последнее не успешно, что лично у меня достаточно частое дело, поэтому проследовал в папку с проектом, удалил папку `node_modules` и выполнил установку модулей вручную при помощи `npm i`. Успех.

## Структура проекта Astro

У фреймворка простейшая структура проекта - несколько конфигов, папка `public` для публичных ассетов, `src` для исходников и вложенная в неё `pages` для маршрутизации на основе файлов, как это было в Next.js до версии 13.

Подробнее про структуру проекта можно почитать в [официальной документации](https://docs.astro.build/en/core-concepts/project-structure/), нет смысла переписывать сюда всё, если уже достаточно понятно объяснено, верно?

Я с таким подходом уже знаком, поэтому сразу полез создавать роуты для главной страницы (есть из коробки - `index.astro`) и для тестовых статей, в том числе и для этой.

## Роутинг

Одной из идей для блога была мультиязычность, потому что я себя ненавижу и хочу писать одно и то же на трёх языках, но в глубине души я вижу в этом пользу для изучения испанского и оттачивания английского.

Имелось несколько стульев:

1. 3 версии сайта, которые содержат статьи под соответствующий язык, в итоге структура страниц выглядела бы примерно так:
   ```
   ├── pages/
       ├── en/
       |   |── index.astro
       |   └── gh-pages-blog-with-astro.mdx
       ├── ru/
       |   |── index.astro
       |   └── gh-pages-blog-with-astro.mdx
       ├── es/
       |   |── index.astro
       |   └── gh-pages-blog-with-astro.mdx
       ├── index.astro
   ```
   Эту идею я сразу забросил, потому что потому. Мне показалось это необоснованно высоким объёмом работы.
2. Изменение языка статьи/сайта на основе query параметров в URL: `tinytengu.github.io/blog?lang=ru`

   На самом деле, достаточно здравая мысль, но мне было слишком лень дополнительно возиться с каким-нибудь фронтэнд фреймворком в духе React.js или Vue.js, чтобы рендерить разные компоненты в зависимости от языка, к тому же, это не совсем клеится с моей идеей использовать Markdown (MDX) в качестве способа написания статей, поскольку разметка в таком случае будет нереально грязной, чего я всячески пытался избежать. Чем ближе я к обычному Markdown документу, тем лучше.

3. Стул третий, который и был выбан. Делать папку для маршрута с вложенными файлами для статьи на каждом языке. Стукрута следующая:
   ```
   ├── pages/
       ├── gh-pages-blog-with-astro/
       |   |── en.mdx
       |   |── es.mdx
       |   └── ru.mdx
       └── index.astro
   ```
   Если присмотреться, то это не сильно отличается от первого варианта, объёмы работы примерно такие же, но я выбрал именно такой вариант, потому что потому. Мне понравилась идея держать файлы со всеми переводами для одной статьи рядом, в одной папке, а не на расстоянии нескольких папок друг от друга, хоть это и вызывает некоторые конфузы, о которых позже.

## Главная страница и макеты

На главной странице я решил просто показывать навбар с логотипом и ссылкой на мой сайт, блог и маленький копирайт, ну и, само собой, список статей, без всяких красивых лэйаутов, просто вертикально расположенные плитки со статьями.

![Home page](/blog/assets/gh-pages-blog-with-astro/home.png)

Не нужно иметь учёной степени, чтобы понять, что страниц на сайте будет больше, чем одна, поэтому я сразу решил пустить в бой макеты (см. [Layouts](https://docs.astro.build/en/core-concepts/layouts/)), если кто не знаком с Next.js, то поясню кратко. Макеты - это способ сделать общую обёртку для набора страниц. На всех страницах у меня будет присутствовать навбар, некоторые мета теги и стили, поэтому, разумной идеей будет вынести это всё в общий макет, в который затем будут встраиваться сами страницы. Решил не мудрить и сначала просто подрезать с документации и поменять, что нужно. Оказалось, что это просто Astro компоненты, имеющие в себе слоты, ничего больше:

```astro
---
// src/layouts/BaseLayout.astro

import Navbar from "@components/Navbar.astro";
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content={Astro.generator} />

    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap"
      rel="stylesheet"
    />

    <slot name="head">
      <title>tinyblog</title>
    </slot>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html {
        font-family: Inter, sans-serif;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <Navbar />
    <main>
      <slot />
    </main>
  </body>
</html>
```

Несмотря на то, что я использую Tailwind (я же говорил, что использую его? Нет? Ну ладно, говорю сейчас, подключение это дело одной команды, см. [здесь](https://github.com/withastro/astro/tree/main/packages/integrations/tailwind)), я решил сбросить отступы и идиотский `box-sizing` а также подключил и установил шрифт [Inter](https://fonts.google.com/specimen/Inter?query=Inter), потому что он в Фигме по умолчанию и в принципе достаточно симпотный.

Теперь, для использования макета, достаточно его импортировать куда надо (в моём случае **в другой макет**, да, так можно, почему нет?) и между его открывающим и закрывающим тегами поместить нужный контент, который попадёт на место плейсхолдера `<slot/>`.

_Слотам, кстати, можно давать имена через атрибут `name` а затем, тегам, которые помещаются в макет, через этот же атрибут `name` указывать слот, в который тег следует поместить._

### Табличку "Фаѝл" в студию

Я решил сделать один базовый макет, один для главной страницы и один для статей, **_но кое-что пошло не так_**. По непонятной причине, стили из `ArticleLayout.astro` перекрывали стили `HomeLayout.astro`, когда я адаптировал вёрстку под мобильные устройства, по абсолютно непонятной причине на домашней странице не обновлялись CSS стили, но они обновлялись при изменении макета статей.

Примечательно, если отключить Glob поиск `.mdx` файлов со статьями, которые используют макет статей или отключить в этих файлах использование макета, всё приходит в норму. По какой-то совершенно необъяснимой причине, макет, который при дебаггинге даже не использовался, перекрывал стили совершенно другого макета.

Абсурдно, но что имеем. Пришлось переделывать адаптивность с гридов на пачку брейкпоинтов от TailwindCSS.

## Статьи

### Список статей

Чтобы сделать процесс создания статей максимально простым, я захотел сделать так, чтобы файлы статей индексировались на главной странице и отображались в виде списка с плитками, это можно достаточно легко сделать при помощи Glob поиска файлов и использования модуля `frontmatter`, который любезно парсит `.mdx` файлы и достаёт из них, конфиги, написанные в заголовки. Файл со статьёй выглядит примерно так:

```markdown
---
layout: "../../layouts/ArticleLayout.astro"

title: "Создание и деплой блога на GitHub Pages с Astro"
caption: "Делаю шустрый блог без бэкэнда, сервера и всяческих затрат, но при помощи Astro и GitHub Pages"
date: "25.11.2022"
duration: "15"
tags: ["Frontend", "Astro", "Гайд"]
languages: ["en", "ru", "es"]
---

Содержимое статьи
```

Как по мне, это довольно удобно, поэтому целью стала индексация этих файлов и вытаскивание оттуда этих конфигов (title, caption, date, ...).

К счастью, проще задачи быть не может, это отлично задокументировано. На помощь приходит Glob поиск файлов по паттерну:

```astro
const articles = await Astro.glob("./**/en.mdx");
```

> Я решил искать статьи только на английском, дабы избежать в списке дубликации, даже двойной, из-за файлов с русским и испанским переводом. Можно было бы просто брать из доступных файлов, но эту логику мне реализовывать лень, быть может, когда-нибудь потом.

Итак, теперь нужно те параметры статьи как-то получить, для этого на каждом объекте в `articles` присутствует поле `frontmatter`, которое и содержит нужные данные. Как это выглядит:

```astro
---
import HomeLayout from "@layouts/HomeLayout.astro";

import Article from "@components/Article.astro";
import type { Article as ArticleType } from "../types";

const articles = await Astro.glob<ArticleType>("./**/en.mdx");
---

<HomeLayout>
  <ul class="flex flex-col gap-1 lg:gap-5 items-center">
    {
      articles.map((article) => (
        <li>
          <Article
            slug={article.url!}
            title={article.frontmatter.title}
            caption={article.frontmatter.caption}
            date={article.frontmatter.date}
            duration={article.frontmatter.duration}
            tags={article.frontmatter.tags}
          />
        </li>
      ))
    }
  </ul>
</HomeLayout>
```

### Отдельная статья

Остаётся лишь отобразить конкретную статью. Для этого я сделал отдельный макет, в котором всё так же можно получать поля `frontmatter` при помощи `Astro.props.frontmatter`.

**Важно отметить**, что при использовании TailwindCSS, разметка Markdown будет сломана, поскольку Tailwind сбрасывает свойства заголовков, параграфов и прочего, а именно они и рендерятся в последствие из Markdown разметки. Для решения этой проблемы я использовать модуль `@tailwindcss/typography` и накинул на тег, который держит в себе всю разметку статьи, классы `prose max-w-none prose-h1:text-5xl` - первый возврвщает тексту стили, второй сбрасиывает ограничение длины строки на 36 символов от первого, третий устанавливает всем h1 заголовкам (или же одной решётке) размер 5xl.

В макете статьи получилось примерно такое вот ольвие (весь код доступен на [GitHub](https://github.com/tinytengu/blog), само собой):

```astro
<BaseLayout>
  <article
    class="prose max-w-none prose-h1:text-5xl w-full lg:w-[960px] px-2 lg:px-0 pb-4 ml-auto mr-auto"
  >
    <!-- Date & Tags header -->
    <header class="flex justify-between opacity-50">
      <p>{props.date}</p>
      <p>{props.tags.join(" / ")}</p>
    </header>
    <!-- Title -->
    <h1>{props.title}</h1>
    <!-- Languages list -->
    <ul class="flex gap-4 list-none px-0">
      {
        props.languages.map((lang: string) => (
          <li class="px-0">
            <a
              href={`${urlCommon}/${lang}`}
              class={language == lang ? "opacity-100" : "opacity-50"}
            >
              {LANGUAGES[lang]}
            </a>
          </li>
        ))
      }
    </ul>
    <slot />
  </article>
</BaseLayout>
```

### Деплой

Хотя у меня уже был написан готовый скрипт для GitHub Workflow, который собирает Vite проект из репозитория и деплоит его в ветку `gh-pages`, ребята из Astro достаточно подробно задокументировали [процесс деплоя на разные сервисы](https://docs.astro.build/en/guides/deploy/), в том числе и [на GitHub](https://docs.astro.build/en/guides/deploy/github/).

![Deploy](/blog/assets/gh-pages-blog-with-astro/astro-deploy.png)

Я буквально один-в-один проследовал за документацией и теперь вы читаете мой блог на GitHub Pages.

### Заключение

Что тут можно написать? Я попробовал Astro, столкнулся с некоторыми странностями, но в остальном всё прошло достаточно гладко и DX оказался достаточно приятным. Определённо продолжу держать этот блог именно на нём, пока полноцененая платформа на Next.js стагнирует в разработке.

Если понравился фреймворк, то быстро к ним [на сайт](https://astro.build) читать документацию и делать классные штуки, а я пойду доделывать этот блог.
